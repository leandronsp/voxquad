<div class="voxquad-container">
  <h1 class="voxquad-title">üéµ VoxQuad SATB Matrix</h1>
  
  <!-- SATB Matrix -->
  <div class="satb-matrix">
    
    <%= render 'chord_headers' %>

    <%= render 'voice_row', voice: 'soprano', gain: 80, notes: ['D5', 'C5', 'C5', 'C5'] %>
    <%= render 'voice_row', voice: 'alto', gain: 70, notes: ['B3', 'C4', 'F4', 'E4'] %>
    <%= render 'voice_row', voice: 'tenor', gain: 70, notes: ['G4', 'F4', 'G#4/Ab4', 'G4'] %>
    <%= render 'voice_row', voice: 'bass', gain: 90, notes: ['G2', 'A2', 'G#2/Ab2', 'C2'] %>
    
    <%= render 'controls' %>
  </div>
</div>

<%= stylesheet_link_tag 'synth' %>

<script>
// Create Web Audio API context
let audioContext = null;

// Musical note system using equal temperament
// Formula: f = 440 √ó 2^((midiNote - 69) / 12)
// A4 = 440 Hz = MIDI note 69

// Chromatic note names and their MIDI numbers (ordered C, C#, D, D#, E, F, F#, G, G#, A, A#, B)
const CHROMATIC_NOTES = [
  // Octave 2 (MIDI 36-47) - Starting with C
  {name: 'C2', midi: 36}, {name: 'C#2/Db2', midi: 37}, {name: 'D2', midi: 38}, {name: 'D#2/Eb2', midi: 39},
  {name: 'E2', midi: 40}, {name: 'F2', midi: 41}, {name: 'F#2/Gb2', midi: 42}, {name: 'G2', midi: 43},
  {name: 'G#2/Ab2', midi: 44}, {name: 'A2', midi: 45}, {name: 'A#2/Bb2', midi: 46}, {name: 'B2', midi: 47},
  
  // Octave 3 (MIDI 48-59) - Starting with C
  {name: 'C3', midi: 48}, {name: 'C#3/Db3', midi: 49}, {name: 'D3', midi: 50}, {name: 'D#3/Eb3', midi: 51},
  {name: 'E3', midi: 52}, {name: 'F3', midi: 53}, {name: 'F#3/Gb3', midi: 54}, {name: 'G3', midi: 55},
  {name: 'G#3/Ab3', midi: 56}, {name: 'A3', midi: 57}, {name: 'A#3/Bb3', midi: 58}, {name: 'B3', midi: 59},
  
  // Octave 4 (MIDI 60-71) - Starting with C
  {name: 'C4', midi: 60}, {name: 'C#4/Db4', midi: 61}, {name: 'D4', midi: 62}, {name: 'D#4/Eb4', midi: 63},
  {name: 'E4', midi: 64}, {name: 'F4', midi: 65}, {name: 'F#4/Gb4', midi: 66}, {name: 'G4', midi: 67},
  {name: 'G#4/Ab4', midi: 68}, {name: 'A4', midi: 69}, {name: 'A#4/Bb4', midi: 70}, {name: 'B4', midi: 71},
  
  // Octave 5 (MIDI 72-83) - Starting with C
  {name: 'C5', midi: 72}, {name: 'C#5/Db5', midi: 73}, {name: 'D5', midi: 74}, {name: 'D#5/Eb5', midi: 75},
  {name: 'E5', midi: 76}, {name: 'F5', midi: 77}, {name: 'F#5/Gb5', midi: 78}, {name: 'G5', midi: 79},
  {name: 'G#5/Ab5', midi: 80}, {name: 'A5', midi: 81}, {name: 'A#5/Bb5', midi: 82}, {name: 'B5', midi: 83}
];

// Chord definitions with their component notes (all octaves included)
const CHORD_DEFINITIONS = {
  // Empty chord - no filtering
  '': { name: 'All Notes', notes: [] },
  
  // Major chords
  'C': { name: 'C Major', notes: ['C', 'E', 'G'] },
  'F': { name: 'F Major', notes: ['F', 'A', 'C'] },
  'G': { name: 'G Major', notes: ['G', 'B', 'D'] },
  'D': { name: 'D Major', notes: ['D', 'F#/Gb', 'A'] },
  'A': { name: 'A Major', notes: ['A', 'C#/Db', 'E'] },
  'E': { name: 'E Major', notes: ['E', 'G#/Ab', 'B'] },
  'B': { name: 'B Major', notes: ['B', 'D#/Eb', 'F#/Gb'] },
  
  // Minor chords  
  'Am': { name: 'A minor', notes: ['A', 'C', 'E'] },
  'Dm': { name: 'D minor', notes: ['D', 'F', 'A'] },
  'Em': { name: 'E minor', notes: ['E', 'G', 'B'] },
  'Bm': { name: 'B minor', notes: ['B', 'D', 'F#/Gb'] },
  'Fm': { name: 'F minor', notes: ['F', 'G#/Ab', 'C'] },
  'Cm': { name: 'C minor', notes: ['C', 'D#/Eb', 'G'] },
  'Gm': { name: 'G minor', notes: ['G', 'A#/Bb', 'D'] },
  
  // Dominant 7th chords
  'G7': { name: 'G7', notes: ['G', 'B', 'D', 'F'] },
  'C7': { name: 'C7', notes: ['C', 'E', 'G', 'A#/Bb'] },
  'F7': { name: 'F7', notes: ['F', 'A', 'C', 'D#/Eb'] },
  'D7': { name: 'D7', notes: ['D', 'F#/Gb', 'A', 'C'] },
  'A7': { name: 'A7', notes: ['A', 'C#/Db', 'E', 'G'] },
  'E7': { name: 'E7', notes: ['E', 'G#/Ab', 'B', 'D'] },
  'B7': { name: 'B7', notes: ['B', 'D#/Eb', 'F#/Gb', 'A'] }
};

// Function to check if a note belongs to a chord (any octave)
function noteInChord(noteName, chordNotes) {
  if (chordNotes.length === 0) return true; // Empty chord = all notes allowed
  
  // Extract base note name (remove octave number)
  const baseName = noteName.replace(/[2-5]$/, '');
  
  return chordNotes.some(chordNote => {
    // Handle enharmonic equivalents (e.g., F#/Gb matches both F# and Gb)
    if (chordNote.includes('/')) {
      const [sharp, flat] = chordNote.split('/');
      return baseName === sharp || baseName === flat;
    }
    return baseName === chordNote;
  });
}


// Calculate frequency from MIDI note number using equal temperament
function midiToFrequency(midiNote) {
  return 440 * Math.pow(2, (midiNote - 69) / 12);
}

// Create note-to-frequency mapping
const NOTE_FREQUENCIES = {};
CHROMATIC_NOTES.forEach(note => {
  const frequency = midiToFrequency(note.midi);
  NOTE_FREQUENCIES[note.name] = frequency;
});

// Generate note options from chromatic notes  
const noteOptions = CHROMATIC_NOTES.map(note => ({
  value: midiToFrequency(note.midi).toFixed(2),
  text: note.name
}));

// Global variables for autocomplete
let currentHighlightedIndex = -1;
let currentOptions = [];

// Autocomplete functionality
function createAutocomplete(inputId, options, onSelect, filterFunction = null) {
  const input = document.getElementById(inputId);
  const dropdown = document.getElementById(inputId + '_dropdown');
  
  let currentFilter = filterFunction ? filterFunction() : [];
  
  function showOptions(query = '') {
    // Apply filtering if provided
    let filteredOptions = filterFunction ? 
      options.filter(opt => filterFunction().length === 0 || filterFunction().some(filter => 
        opt.searchText ? opt.searchText.toLowerCase().includes(filter.toLowerCase()) : 
        opt.text.toLowerCase().includes(filter.toLowerCase())
      )) : options;
    
    // Apply search query filter
    if (query) {
      filteredOptions = filteredOptions.filter(opt => 
        opt.text.toLowerCase().includes(query.toLowerCase())
      );
    }
    
    currentOptions = filteredOptions.slice(0, 8); // Limit to 8 options
    currentHighlightedIndex = -1;
    
    if (currentOptions.length === 0) {
      dropdown.style.display = 'none';
      return;
    }
    
    dropdown.innerHTML = '';
    currentOptions.forEach((option, index) => {
      const div = document.createElement('div');
      div.className = 'autocomplete-option';
      div.textContent = option.text;
      div.addEventListener('click', () => {
        selectOption(option);
      });
      dropdown.appendChild(div);
    });
    
    dropdown.style.display = 'block';
  }
  
  function selectOption(option) {
    input.value = option.text;
    dropdown.style.display = 'none';
    onSelect(option);
  }
  
  function hideDropdown() {
    setTimeout(() => {
      dropdown.style.display = 'none';
    }, 150); // Small delay to allow clicks
  }
  
  // Event listeners
  input.addEventListener('input', (e) => {
    showOptions(e.target.value);
  });
  
  input.addEventListener('focus', () => {
    showOptions(input.value);
  });
  
  input.addEventListener('blur', hideDropdown);
  
  input.addEventListener('keydown', (e) => {
    if (dropdown.style.display === 'none') return;
    
    if (e.key === 'ArrowDown') {
      e.preventDefault();
      currentHighlightedIndex = Math.min(currentHighlightedIndex + 1, currentOptions.length - 1);
      updateHighlight();
    } else if (e.key === 'ArrowUp') {
      e.preventDefault();
      currentHighlightedIndex = Math.max(currentHighlightedIndex - 1, -1);
      updateHighlight();
    } else if (e.key === 'Enter') {
      e.preventDefault();
      if (currentHighlightedIndex >= 0) {
        selectOption(currentOptions[currentHighlightedIndex]);
      }
    } else if (e.key === 'Escape') {
      dropdown.style.display = 'none';
    }
  });
  
  function updateHighlight() {
    const options = dropdown.children;
    for (let i = 0; i < options.length; i++) {
      options[i].classList.toggle('highlighted', i === currentHighlightedIndex);
    }
  }
  
  return {
    updateFilter: (newFilterFunction) => {
      filterFunction = newFilterFunction;
      if (input === document.activeElement) {
        showOptions(input.value);
      }
    },
    setValue: (value) => {
      const option = options.find(opt => opt.value === value || opt.text === value);
      if (option) {
        input.value = option.text;
        onSelect(option);
      }
    }
  };
}

// Helper function to get frequency by note name
function getFrequencyByNote(noteName) {
  return NOTE_FREQUENCIES[noteName].toFixed(2);
}

// Prepare chord options for autocomplete
const chordOptions = [
  { value: '', text: 'All Notes' },
  // Key of C major progression first
  { value: 'C', text: 'C Major' },
  { value: 'Dm', text: 'D minor' }, 
  { value: 'Em', text: 'E minor' },
  { value: 'F', text: 'F Major' },
  { value: 'G', text: 'G Major' },
  { value: 'Am', text: 'A minor' },
  { value: 'G7', text: 'G7' },
  // Other majors
  { value: 'D', text: 'D Major' },
  { value: 'E', text: 'E Major' },
  { value: 'A', text: 'A Major' },
  { value: 'B', text: 'B Major' },
  // Other minors
  { value: 'Bm', text: 'B minor' },
  { value: 'Fm', text: 'F minor' },
  { value: 'Cm', text: 'C minor' },
  { value: 'Gm', text: 'G minor' },
  // Other 7ths
  { value: 'C7', text: 'C7' },
  { value: 'F7', text: 'F7' },
  { value: 'D7', text: 'D7' },
  { value: 'A7', text: 'A7' },
  { value: 'E7', text: 'E7' },
  { value: 'B7', text: 'B7' }
];

// Store autocomplete instances and current chord selections
const autocompleteInstances = {};
const currentChords = { 1: '', 2: '', 3: '', 4: '' };

// Initialize all dropdowns when page loads
document.addEventListener('DOMContentLoaded', () => {
  // Initialize chord autocompletes
  for (let i = 1; i <= 4; i++) {
    autocompleteInstances[`chord_m${i}`] = createAutocomplete(
      `chord_m${i}`,
      chordOptions,
      (option) => {
        currentChords[i] = option.value;
        // Chord selection is now purely informational - no filtering
      }
    );
  }
  
  // Initialize voice autocompletes for all measures and voices (no filtering)
  const voiceNames = ['soprano', 'alto', 'tenor', 'bass'];
  for (let measure = 1; measure <= 4; measure++) {
    voiceNames.forEach(voice => {
      const inputId = `m${measure}_${voice}`;
      autocompleteInstances[inputId] = createAutocomplete(
        inputId,
        noteOptions,
        (option) => {
          // Note selected - no additional action needed
        }
        // No filter function - all notes always available
      );
    });
  }
  
  // Set initial values from the image progression
  autocompleteInstances['chord_m1'].setValue('G Major');
  autocompleteInstances['chord_m2'].setValue('F Major');
  autocompleteInstances['chord_m3'].setValue('F minor');
  autocompleteInstances['chord_m4'].setValue('C Major');
  
  // Set initial note values to match the image
  autocompleteInstances['m1_soprano'].setValue('D5');
  autocompleteInstances['m1_alto'].setValue('B3');
  autocompleteInstances['m1_tenor'].setValue('G4');
  autocompleteInstances['m1_bass'].setValue('G2');
  
  autocompleteInstances['m2_soprano'].setValue('C5');
  autocompleteInstances['m2_alto'].setValue('C4');
  autocompleteInstances['m2_tenor'].setValue('F4');
  autocompleteInstances['m2_bass'].setValue('A2');
  
  autocompleteInstances['m3_soprano'].setValue('C5');
  autocompleteInstances['m3_alto'].setValue('F4');
  autocompleteInstances['m3_tenor'].setValue('G#4/Ab4');
  autocompleteInstances['m3_bass'].setValue('G#2/Ab2');
  
  autocompleteInstances['m4_soprano'].setValue('C5');
  autocompleteInstances['m4_alto'].setValue('E4');
  autocompleteInstances['m4_tenor'].setValue('G4');
  autocompleteInstances['m4_bass'].setValue('C2');
});

// Chord dropdowns are purely informational - no filtering logic needed

// Update master volume display
document.getElementById('masterVolume').addEventListener('input', (e) => {
  document.getElementById('masterVolumeValue').textContent = e.target.value + '%';
});

// Add 4-Measure SATB playback
document.getElementById('playSATB').addEventListener('click', () => {
  if (!audioContext) {
    audioContext = new (window.AudioContext || window.webkitAudioContext)();
  }
  
  play4MeasureSATB();
});


// Vowel formant frequencies (F1, F2) based on acoustic research
const VOWEL_FORMANTS = {
  a: [827, 1542],  // "bat" - open central vowel
  e: [430, 2336],  // "bet" - mid front vowel  
  i: [100, 3379],  // "beet" - close front vowel
  o: [562, 3577],  // "bought" - mid back vowel
  u: [200, 1500]   // "boot" - close back vowel
};

// Voice-specific formant frequency scaling
const VOICE_SCALING = {
  soprano: 1.2,   // Higher formants
  alto: 1.1,      // Slightly higher
  tenor: 1.0,     // Base frequencies  
  bass: 0.85      // Lower formants
};

// Create formant synthesizer based on acoustic principles
function createFormantVoice(frequency, voiceType, vowel = 'a') {
  // Get formant frequencies for the vowel
  const baseFormants = VOWEL_FORMANTS[vowel] || VOWEL_FORMANTS.a;
  const scalingFactor = VOICE_SCALING[voiceType] || 1.0;
  
  // Scale formants for voice type
  const f1 = baseFormants[0] * scalingFactor;
  const f2 = baseFormants[1] * scalingFactor;
  
  // Single sawtooth source (like vocal cords)
  const source = audioContext.createOscillator();
  source.frequency.value = frequency;
  source.type = 'sawtooth';
  
  // Create resonant formant filters in SERIES (not parallel!)
  // This simulates how vocal tract actually works
  const formant1 = audioContext.createBiquadFilter();
  formant1.type = 'peaking'; // Use peaking filter for resonance
  formant1.frequency.value = f1;
  formant1.Q.value = 10; // High Q for strong resonance
  formant1.gain.value = 12; // Boost at this frequency
  
  const formant2 = audioContext.createBiquadFilter();
  formant2.type = 'peaking';
  formant2.frequency.value = f2;
  formant2.Q.value = 15; // Even higher Q for F2
  formant2.gain.value = 8; // Less boost than F1
  
  // Lowpass to remove harsh high frequencies
  const lowpass = audioContext.createBiquadFilter();
  lowpass.type = 'lowpass';
  lowpass.frequency.value = 3000;
  lowpass.Q.value = 1;
  
  // Output gain control
  const outputGain = audioContext.createGain();
  outputGain.gain.value = 0.1; // Much quieter for peaking filters
  
  // Connect in series: source -> formant1 -> formant2 -> lowpass -> output
  source.connect(formant1);
  formant1.connect(formant2);
  formant2.connect(lowpass);
  lowpass.connect(outputGain);
  
  return { 
    oscillator: source,
    outputNode: outputGain 
  };
}

function playSATB(frequencies, duration, startTime = 0, voiceGains = [1, 1, 1, 1]) {
  const voices = [];
  const gainNodes = [];
  
  // Create master gain
  const masterGain = audioContext.createGain();
  masterGain.connect(audioContext.destination);
  
  const masterVolume = document.getElementById('masterVolume').value / 100;
  const voiceNames = ['soprano', 'alto', 'tenor', 'bass'];
  
  // Create formant voice for each SATB part
  frequencies.forEach((frequency, index) => {
    const voice = createFormantVoice(frequency, voiceNames[index], 'a');
    const gainNode = audioContext.createGain();
    
    // Connect voice -> gain -> master
    voice.outputNode.connect(gainNode);
    gainNode.connect(masterGain);
    
    // Set individual voice gain
    const voiceGainSlider = document.getElementById(`${voiceNames[index]}Gain`);
    const voiceGainValue = voiceGainSlider ? voiceGainSlider.value / 100 : 0.8;
    gainNode.gain.value = voiceGainValue * 0.4;
    
    voices.push(voice);
    gainNodes.push(gainNode);
  });
  
  // Apply ADSR envelope
  const now = audioContext.currentTime + startTime;
  masterGain.gain.setValueAtTime(0, now);
  masterGain.gain.linearRampToValueAtTime(masterVolume, now + 0.05);
  masterGain.gain.linearRampToValueAtTime(masterVolume * 0.9, now + 0.1);
  masterGain.gain.linearRampToValueAtTime(masterVolume * 0.9, now + duration - 0.1);
  masterGain.gain.linearRampToValueAtTime(0, now + duration);
  
  // Start all voices
  voices.forEach(voice => {
    voice.oscillator.start(now);
    voice.oscillator.stop(now + duration);
  });
}

function play4MeasureSATB() {
  const measureDuration = 1.2; // 1.2 seconds per measure
  
  // Get all measure data from input fields
  const measures = [];
  for (let i = 1; i <= 4; i++) {
    // Convert note names to frequencies
    const sopranoNote = document.getElementById(`m${i}_soprano`).value;
    const altoNote = document.getElementById(`m${i}_alto`).value;
    const tenorNote = document.getElementById(`m${i}_tenor`).value;
    const bassNote = document.getElementById(`m${i}_bass`).value;
    
    const soprano = sopranoNote ? NOTE_FREQUENCIES[sopranoNote] || parseFloat(sopranoNote) : 0;
    const alto = altoNote ? NOTE_FREQUENCIES[altoNote] || parseFloat(altoNote) : 0;
    const tenor = tenorNote ? NOTE_FREQUENCIES[tenorNote] || parseFloat(tenorNote) : 0;
    const bass = bassNote ? NOTE_FREQUENCIES[bassNote] || parseFloat(bassNote) : 0;
    
    if (soprano && alto && tenor && bass) {
      measures.push({
        frequencies: [soprano, alto, tenor, bass],
        measure: i
      });
    }
  }
  
  if (measures.length === 0) {
    alert('Please select notes for all voices in at least one measure');
    return;
  }
  
  // Schedule all measures using Web Audio API timing
  measures.forEach((measure, index) => {
    const startTime = index * measureDuration;
    playSATB(measure.frequencies, measureDuration, startTime);
  });
  
  // Visual feedback
  document.getElementById('playSATB').style.background = '#7B1FA2';
  document.getElementById('playSATB').textContent = 'üéµ Playing...';
  
  // Reset button after playback
  setTimeout(() => {
    document.getElementById('playSATB').style.background = '#9C27B0';
    document.getElementById('playSATB').textContent = '‚ñ∂Ô∏è Play Composition';
  }, measureDuration * measures.length * 1000);
}
</script>
